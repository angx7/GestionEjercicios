CONSTANTE SEC_POR_REP ← 5
CONSTANTE DESCANSO_ENTRE_SERIES ← 30

FUNCIÓN MINUTOS_A_TEXTO(mins):
    total ← redondear(mins * 60)
    m, s ← dividir_mod(total, 60)
    DEVOLVER texto "{m} min {s} s"

FUNCIÓN NORM(s):
    DEVOLVER s.sin_espacios().minusculas()

FUNCIÓN MK_EJERCICIO(nombre, repeticiones, series, sec_por_rep = SEC_POR_REP, descanso = DESCANSO_ENTRE_SERIES):
    e ← { nombre: trim(nombre),
          repeticiones: entero(repeticiones),
          series: entero(series),
          sec_por_rep: entero(sec_por_rep),
          descanso_entre_series: entero(descanso) }
    VALIDAR_EJERCICIO(e)
    DEVOLVER e

PROCEDIMIENTO VALIDAR_EJERCICIO(e):
    SI e.nombre = ""              → ERROR "Nombre vacío"
    SI e.repeticiones ≤ 0         → ERROR
    SI e.repeticiones > 100       → ERROR
    SI e.series ≤ 0               → ERROR
    SI e.series > 100             → ERROR
    SI e.sec_por_rep ≤ 0          → ERROR
    SI e.descanso_entre_series < 0→ ERROR

FUNCIÓN DURACION_EJERCICIO_MIN(e):
    movimiento_seg ← e.repeticiones * e.sec_por_rep * e.series
    descanso_seg   ← e.descanso_entre_series * MAX(0, e.series - 1)
    DEVOLVER (movimiento_seg + descanso_seg) / 60

FUNCIÓN STR_EJERCICIO(e):
    DEVOLVER "nombre | reps: ... | series: ... | estimado: MINUTOS_A_TEXTO(DURACION_EJERCICIO_MIN(e))"

FUNCIÓN ACTUALIZAR_EJERCICIO(e, rep?, ser?):
    nuevo ← copia(e)
    SI rep definido:
        SI rep ≤ 0 → ERROR
        nuevo.repeticiones ← rep
    SI ser definido:
        SI ser ≤ 0 → ERROR
        nuevo.series ← ser
    VALIDAR_EJERCICIO(nuevo)
    DEVOLVER nuevo

FUNCIÓN MK_RUTINA(nombre, descripcion, lista_ejercicios):
    r ← { nombre: trim(nombre),
          descripcion: trim(descripcion),
          ejercicios: copia(lista_ejercicios) }
    VALIDAR_RUTINA(r)
    DEVOLVER r

PROCEDIMIENTO VALIDAR_RUTINA(r):
    SI r.nombre = ""        → ERROR
    SI r.descripcion = ""   → ERROR
    SI r.ejercicios está vacía → ERROR
    nombres_normalizados ← map(NORM, map(tomar_nombre, r.ejercicios))
    hay_dup ← ACUMULAR_DUPLICADOS(nombres_normalizados)
    SI hay_dup → ERROR "Duplicados"

FUNCIÓN ACUMULAR_DUPLICADOS(lista):
    vistos ← ∅
    DUP ← FALSO
    PARA cada nom en lista:
        SI nom ∈ vistos → DUP ← VERDADERO
        vistos ← vistos ∪ {nom}
    DEVOLVER DUP

FUNCIÓN RUTINA_AGREGAR_EJERCICIO(r, e):
    key ← NORM(e.nombre)
    existe ← ALGUNO(r.ejercicios, λej → NORM(ej.nombre)=key)
    SI existe → ERROR "Ya existe"
    nueva_lista ← r.ejercicios + [e]
    DEVOLVER MK_RUTINA(r.nombre, r.descripcion, nueva_lista)

FUNCIÓN RUTINA_ELIMINAR_EJERCICIO(r, nombre_ejercicio):
    key ← NORM(nombre_ejercicio)
    nueva ← FILTRAR(r.ejercicios, λej → NORM(ej.nombre) ≠ key)
    SI tamaño(nueva) = tamaño(r.ejercicios) → ERROR "No encontrado"
    SI nueva está vacía → ERROR "Rutina no puede quedar vacía"
    DEVOLVER MK_RUTINA(r.nombre, r.descripcion, nueva)

FUNCIÓN RUTINA_BUSCAR_EJERCICIO(r, nombre_ejercicio):     // recursiva
    key ← NORM(nombre_ejercicio)
    DEVOLVER BUSCAR_RECURSIVO(r.ejercicios)

    FUNCIÓN BUSCAR_RECURSIVO(lst):
        SI lst vacía → ERROR "No encontrado"
        ej ← primero(lst)
        SI NORM(ej.nombre) = key → DEVOLVER ej
        SINO DEVOLVER BUSCAR_RECURSIVO(resto(lst))

FUNCIÓN RUTINA_ACTUALIZAR_EJERCICIO(r, nombre_ejercicio, rep?, ser?):
    key ← NORM(nombre_ejercicio)
    nueva ← map(λej → si NORM(ej.nombre)=key entonces ACTUALIZAR_EJERCICIO(ej, rep, ser) sino ej, r.ejercicios)
    existia ← EXISTIA_EN_ORIGINAL(r.ejercicios, key)
    SI NO existia → ERROR "No encontrado"
    DEVOLVER MK_RUTINA(r.nombre, r.descripcion, nueva)

FUNCIÓN EXISTIA_EN_ORIGINAL(lista, key):
    DEVOLVER ALGUNO(lista, λej → NORM(ej.nombre)=key)

FUNCIÓN RUTINA_DURACION_TOTAL_MIN(r):
    DEVOLVER SUMAR(map(DURACION_EJERCICIO_MIN, r.ejercicios))

FUNCIÓN STR_RUTINA(r):
    DEVOLVER texto multilínea con nombre, descripción, total en texto y número de ejercicios

FUNCIÓN RUTINA_ACTUALIZAR_DATOS(r, nombre?, descripcion?):
    nuevo_nombre ← si nombre definido entonces trim(nombre) sino r.nombre
    nueva_desc   ← si descripcion definida entonces trim(descripcion) sino r.descripcion
    SI nombre definido Y nuevo_nombre = "" → ERROR
    SI descripcion definida Y nueva_desc = "" → ERROR
    DEVOLVER MK_RUTINA(nuevo_nombre, nueva_desc, r.ejercicios)

FUNCIÓN MK_USUARIO(nombre, edad):
    u ← { nombre: trim(nombre), edad: entero(edad), rutinas: [] }
    VALIDAR_USUARIO(u)
    DEVOLVER u

PROCEDIMIENTO VALIDAR_USUARIO(u):
    SI u.nombre = "" → ERROR
    SI u.edad < 16   → ERROR
    SI u.edad > 100  → ERROR

FUNCIÓN USUARIO_ASIGNAR_RUTINA(u, r):
    key ← NORM(r.nombre)
    ya ← ALGUNO(u.rutinas, λrr → NORM(rr.nombre)=key)
    SI ya → ERROR "Ya tiene una rutina con ese nombre"
    DEVOLVER { nombre: u.nombre, edad: u.edad, rutinas: u.rutinas + [r] }

FUNCIÓN STR_USUARIO(u):
    DEVOLVER "Usuario: ... | Edad: ... | Rutinas: cantidad"

FUNCIÓN ESTADO_VACIO():
    DEVOLVER {
      usuarios: [],
      ejercicios_catalogo: [],
      rutinas: [],
      idx_usuarios: {},     // clave: nombre normalizado → usuario
      idx_ejercicios: {},   // clave: nombre normalizado → ejercicio
      idx_rutinas: {}       // clave: nombre normalizado → rutina
    }

}FUNCIÓN INPUT_NO_VACIO(msg):
    txt ← leer(msg).trim()
    SI txt ≠ "" → DEVOLVER txt
    imprimir("No puede estar vacío")
    DEVOLVER INPUT_NO_VACIO(msg)

FUNCIÓN INPUT_INT(msg, minimo?, maximo?):
    raw ← leer(msg).trim()
    SI no es entero → imprimir("Entero válido"); DEVOLVER INPUT_INT(msg, minimo, maximo)
    val ← entero(raw)
    SI minimo definido y val < minimo → imprimir("≥ minimo"); DEVOLVER INPUT_INT(...)
    SI maximo definido y val > maximo → imprimir("≤ maximo"); DEVOLVER INPUT_INT(...)
    DEVOLVER val

PROCEDIMIENTO PRINT(msg):
    imprimir(msg)

FUNCIÓN BUSCAR_USUARIO(st, nombre):   DEVOLVER st.idx_usuarios[NORM(nombre)] o NULO
FUNCIÓN BUSCAR_EJERCICIO(st, nombre): DEVOLVER st.idx_ejercicios[NORM(nombre)] o NULO
FUNCIÓN BUSCAR_RUTINA(st, nombre):    DEVOLVER st.idx_rutinas[NORM(nombre)] o NULO

FUNCIÓN AGREGAR_USUARIO(st, nombre, edad):
    key ← NORM(nombre)
    SI key ∈ st.idx_usuarios → ERROR "Duplicado"
    u ← MK_USUARIO(nombre, edad)
    nuevos_idx ← copia(st.idx_usuarios); nuevos_idx[key] ← u
    DEVOLVER st con:
        usuarios = st.usuarios + [u],
        idx_usuarios = nuevos_idx

PROCEDIMIENTO LISTAR_USUARIOS(st):
    SI st.usuarios vacío → PRINT("No hay usuarios")
    SINO imprimir recursivamente STR_USUARIO(u) para cada u

PROCEDIMIENTO MOSTRAR_RUTINAS_DE_USUARIO(st, nombre_usuario):
    u ← BUSCAR_USUARIO(st, nombre_usuario)
    SI u = NULO → PRINT("No encontrado")
    SI u.rutinas vacío → PRINT("{nombre} sin rutinas")
    SINO imprimir recursivamente " - {nombre}: {duración}"

FUNCIÓN CREAR_EJERCICIO(st, nombre, rep, ser):
    key ← NORM(nombre)
    SI key ∈ st.idx_ejercicios → ERROR
    ej ← MK_EJERCICIO(nombre, rep, ser)
    idx ← copia(st.idx_ejercicios); idx[key] ← ej
    PRINT("Duración estimada: MINUTOS_A_TEXTO(DURACION_EJERCICIO_MIN(ej))")
    DEVOLVER st con:
        ejercicios_catalogo = + [ej],
        idx_ejercicios = idx

PROCEDIMIENTO LISTAR_EJERCICIOS(st):
    SI catálogo vacío → PRINT("(Catálogo vacío)")
    SINO imprimir recursivamente "- " + STR_EJERCICIO(e)

FUNCIÓN ELIMINAR_EJERCICIO(st, nombre):
    key ← NORM(nombre)
    ej ← st.idx_ejercicios[key] o ERROR "No encontrado"
    nueva_lista ← FILTRAR(st.ejercicios_catalogo, λe → e ≠ ej)
    nuevas_rutinas ← map(λr → intentar RUTINA_ELIMINAR_EJERCICIO(r, ej.nombre) si existe; si falla, r)
    nuevo_idx ← copia(st.idx_ejercicios); eliminar clave key
    DEVOLVER st con:
        ejercicios_catalogo = nueva_lista,
        rutinas = nuevas_rutinas,
        idx_ejercicios = nuevo_idx

FUNCIÓN OBTENER_EJERCICIOS_POR_NOMBRES(st, nombres):
    // recursivo, validando duplicados y existencia en catálogo
    DEVOLVER GO(nombres, vistos=∅, acc=[])

    FUNCIÓN GO(pend, vistos, acc):
        SI pend vacío → DEVOLVER acc
        n ← primero(pend); key ← NORM(n)
        SI key ∈ vistos → ERROR "Nombre repetido"
        ej ← st.idx_ejercicios[key] o ERROR "No existe en catálogo"
        DEVOLVER GO(resto(pend), vistos ∪ {key}, acc + [ej])

FUNCIÓN CREAR_RUTINA(st, nombre, descripcion, nombres_ejercicios):
    SI catálogo vacío → ERROR
    SI nombres_ejercicios vacío → ERROR
    key ← NORM(nombre)
    SI key ∈ st.idx_rutinas → ERROR
    ejercicios ← OBTENER_EJERCICIOS_POR_NOMBRES(st, nombres_ejercicios)
    r ← MK_RUTINA(nombre, descripcion, ejercicios)
    idx ← copia(st.idx_rutinas); idx[key] ← r
    DEVOLVER st con: rutinas = +[r], idx_rutinas = idx

PROCEDIMIENTO LISTAR_RUTINAS(st):
    SI st.rutinas vacío → PRINT("No hay rutinas")
    SINO PARA cada r:
        PRINT("-----"); PRINT(STR_RUTINA(r))
        imprimir recursivamente " • " + STR_EJERCICIO(e) para e en r.ejercicios
    PRINT("-----")

FUNCIÓN EDITAR_RUTINA(st, nombre, nuevo_nombre?, nueva_desc?):
    r ← BUSCAR_RUTINA(st, nombre) o ERROR
    old_key ← NORM(r.nombre)
    r2 ← RUTINA_ACTUALIZAR_DATOS(r, nuevo_nombre, nueva_desc)
    new_key ← NORM(r2.nombre)
    SI new_key ≠ old_key Y new_key ∈ st.idx_rutinas → ERROR "Nombre en uso"
    nuevas_rutinas ← map(reemplaza r por r2 en st.rutinas)
    idx ← copia(st.idx_rutinas)
    SI new_key ≠ old_key → idx.eliminar(old_key)
    idx[new_key] ← r2
    DEVOLVER st con esas listas/índices

FUNCIÓN RUTINA_AGREGAR_EJERCICIO_ST(st, nombre_rutina, nombre_ejercicio):
    r ← BUSCAR_RUTINA(...) o ERROR
    ej ← BUSCAR_EJERCICIO(...) o ERROR
    r2 ← RUTINA_AGREGAR_EJERCICIO(r, ej)
    nuevas ← map(reemplaza r por r2 en st.rutinas)
    idx ← copia(st.idx_rutinas); idx[NORM(r2.nombre)] ← r2
    DEVOLVER st actualizado

FUNCIÓN RUTINA_ELIMINAR_EJERCICIO_ST(st, nombre_rutina, nombre_ejercicio):
    r ← BUSCAR_RUTINA(...) o ERROR
    r2 ← RUTINA_ELIMINAR_EJERCICIO(r, nombre_ejercicio)
    nuevas/idx ← actualizar como arriba
    DEVOLVER st

FUNCIÓN RUTINA_ACTUALIZAR_EJERCICIO_ST(st, nombre_rutina, nombre_ejercicio, rep?, ser?):
    r ← BUSCAR_RUTINA(...) o ERROR
    r2 ← RUTINA_ACTUALIZAR_EJERCICIO(r, nombre_ejercicio, rep, ser)
    nuevas/idx ← actualizar como arriba
    DEVOLVER st

FUNCIÓN ASIGNAR_RUTINA_A_USUARIO(st, nombre_usuario, nombre_rutina):
    u ← BUSCAR_USUARIO(...) o ERROR
    r ← BUSCAR_RUTINA(...) o ERROR
    u2 ← USUARIO_ASIGNAR_RUTINA(u, r)
    nuevos_usuarios ← map(reemplaza u por u2 en st.usuarios)
    idx ← copia(st.idx_usuarios); idx[NORM(u2.nombre)] ← u2
    DEVOLVER st actualizado

PROCEDIMIENTO REPORTE_POR_USUARIO(st):
    SI st.usuarios vacío → PRINT("No hay usuarios")
    SINO para cada u:
        PRINT("===="); PRINT("Usuario: ... | Edad: ...")
        SI u.rutinas vacío → PRINT("(Sin rutinas)")
        SINO imprimir recursivamente " - {nombre}: {duración_total(r)}"
    PRINT("====")

PROCEDIMIENTO MENU_PRINCIPAL(st):
    IMPRIME opciones (Usuarios, Ejercicios, Rutinas, Asignar, Mostrar, Reporte, Salir)
    op ← leer_opción()

    INTENTAR:
        SEGÚN op:
            "1" → MENU_USUARIOS(st)
            "2" → MENU_EJERCICIOS(st)
            "3" → MENU_RUTINAS(st)
            "4" → u ← PEDIR_USUARIO_NOMBRE()
                   PRINT("Rutinas disponibles:"); LISTAR_RUTINAS(st)
                   r_line ← PEDIR_NO_VACIO("Rutinas (coma): ")
                   nombres ← PARSEAR_COMAS(r_line)
                   state ← st; errores ← []
                   PARA cada nombre_r en nombres:
                       INTENTAR state ← ASIGNAR_RUTINA_A_USUARIO(state, u, nombre_r)
                       SI ERROR e → errores.agregar("{nombre_r}: e")
                   SI errores no vacío:
                       PRINT("Algunos errores:"); imprimir_recursivo(errores)
                       MENU_PRINCIPAL(state)
                   SINO:
                       PRINT("Rutinas asignadas."); MENU_PRINCIPAL(state)
            "5" → nombre ← leer("Usuario: "); MOSTRAR_RUTINAS_DE_USUARIO(st, nombre); MENU_PRINCIPAL(st)
            "6" → REPORTE_POR_USUARIO(st); MENU_PRINCIPAL(st)
            "7" → PRINT("Hasta luego."); RETORNAR
            OTRO → PRINT("Opción no válida."); MENU_PRINCIPAL(st)
    SI CAPTURA ERROR e:
        PRINT("[Error] " + e); MENU_PRINCIPAL(st)

PROCEDIMIENTO MENU_USUARIOS(st):
    IMPRIME (Agregar, Listar, Editar, Volver)
    op ← leer

    SI op = "1":
        nombre ← REPETIR_HASTA( pred: BUSCAR_USUARIO(st, n) = NULO,
                                prompt: "Nombre: ",
                                msg_dup: "Ya existe" )
        edad ← INPUT_INT("Edad: ", 16, 100)
        INTENTAR:
            st2 ← AGREGAR_USUARIO(st, nombre, edad)
            PRINT("Agregado"); MENU_USUARIOS(st2)
        SI ERROR e:
            PRINT("[Error] " + e); MENU_USUARIOS(st)

    SI op = "2":
        LISTAR_USUARIOS(st); MENU_USUARIOS(st)

    SI op = "3":
        nombre ← INPUT_NO_VACIO("Usuario a editar: ")
        u ← BUSCAR_USUARIO(st, nombre)
        SI u = NULO → PRINT("No existe"); MENU_USUARIOS(st)
        SINO SUBMENU_EDITAR_USUARIO(st, u)

    SI op = "4": MENU_PRINCIPAL(st)
    OTRO: PRINT("Opción no válida"); MENU_USUARIOS(st)

FUNCIÓN REPETIR_HASTA(pred_ok, prompt, msg_dup):
    val ← INPUT_NO_VACIO(prompt)
    SI pred_ok(val) → DEVOLVER val
    PRINT(msg_dup)
    DEVOLVER REPETIR_HASTA(pred_ok, prompt, msg_dup)

PROCEDIMIENTO SUBMENU_EDITAR_USUARIO(st, u):
    IMPRIME (Cambiar nombre, Cambiar edad, Volver)
    subop ← leer

    SI subop = "1":
        nuevo ← REPETIR_HASTA( BUSCAR_USUARIO(st, n)=NULO, "Nuevo nombre: ", "Ya existe")
        old_key ← NORM(u.nombre)
        u2 ← { nombre: trim(nuevo), edad: u.edad, rutinas: u.rutinas }
        idx ← copia(st.idx_usuarios); idx.eliminar(old_key); idx[NORM(u2.nombre)] ← u2
        lista ← map(reemplaza u por u2 en st.usuarios)
        PRINT("Nombre actualizado")
        SUBMENU_EDITAR_USUARIO(st con usuarios=lista, idx_usuarios=idx, u2)

    SI subop = "2":
        nueva_edad ← INPUT_INT("Nueva edad: ", 16, 100)
        u2 ← { nombre: u.nombre, edad: nueva_edad, rutinas: u.rutinas }
        idx ← copia(st.idx_usuarios); idx[NORM(u2.nombre)] ← u2
        lista ← map(reemplaza u por u2 en st.usuarios)
        PRINT("Edad actualizada")
        SUBMENU_EDITAR_USUARIO(st actualizado, u2)

    SI subop = "3": MENU_USUARIOS(st)
    OTRO: PRINT("Opción no válida"); SUBMENU_EDITAR_USUARIO(st, u)

PROCEDIMIENTO MENU_EJERCICIOS(st):
    IMPRIME (Crear, Listar, Editar, Eliminar, Volver)
    op ← leer

    SI op = "1":
        nombre ← REPETIR_HASTA(BUSCAR_EJERCICIO(st,n)=NULO, "Nombre: ", "Duplicado")
        reps ← INPUT_INT("Reps: ", 1, 100)
        series ← INPUT_INT("Series: ", 1, 100)
        INTENTAR st2 ← CREAR_EJERCICIO(st, nombre, reps, series); MENU_EJERCICIOS(st2)
        SI ERROR e: PRINT("[Error]"); MENU_EJERCICIOS(st)

    SI op = "2": LISTAR_EJERCICIOS(st); MENU_EJERCICIOS(st)

    SI op = "3":
        nombre ← INPUT_NO_VACIO("Ejercicio a editar: ")
        ej ← BUSCAR_EJERCICIO(st, nombre)
        SI ej = NULO → PRINT("No existe"); MENU_EJERCICIOS(st)
        SINO SUBMENU_EDITAR_EJERCICIO(st, ej)

    SI op = "4":
        nombre ← INPUT_NO_VACIO("Nombre a eliminar: ")
        INTENTAR st2 ← ELIMINAR_EJERCICIO(st, nombre); PRINT("Eliminado"); MENU_EJERCICIOS(st2)
        SI ERROR e: PRINT("[Error]"); MENU_EJERCICIOS(st)

    SI op = "5": MENU_PRINCIPAL(st)
    OTRO: PRINT("Opción no válida"); MENU_EJERCICIOS(st)

PROCEDIMIENTO SUBMENU_EDITAR_EJERCICIO(st, ej):
    IMPRIME (Cambiar nombre, Cambiar repeticiones, Cambiar series, Volver)
    subop ← leer

    SI subop = "1":
        nuevo ← REPETIR_HASTA(BUSCAR_EJERCICIO(st,n)=NULO, "Nuevo nombre: ", "Duplicado")
        old_key ← NORM(ej.nombre)
        ej2 ← copia(ej); ej2.nombre ← trim(nuevo)
        idx ← copia(st.idx_ejercicios); idx.eliminar(old_key); idx[NORM(ej2.nombre)] ← ej2
        cat ← map(reemplaza ej por ej2 en st.ejercicios_catalogo)
        PRINT("Nombre actualizado")
        SUBMENU_EDITAR_EJERCICIO(st con idx_ejercicios=idx, ejercicios_catalogo=cat, ej2)

    SI subop = "2":
        nuevas_reps ← INPUT_INT("Nuevas reps: ", 1, 100)
        ej2 ← ACTUALIZAR_EJERCICIO(ej, rep=nuevas_reps)
        actualizar índices y catálogo como arriba
        SUBMENU_EDITAR_EJERCICIO(st actualizado, ej2)

    SI subop = "3":
        nuevas_series ← INPUT_INT("Nuevas series: ", 1, 100)
        ej2 ← ACTUALIZAR_EJERCICIO(ej, ser=nuevas_series)
        actualizar índices y catálogo
        SUBMENU_EDITAR_EJERCICIO(st actualizado, ej2)

    SI subop = "4": MENU_EJERCICIOS(st)
    OTRO: PRINT("Opción no válida"); SUBMENU_EDITAR_EJERCICIO(st, ej)

PROCEDIMIENTO MENU_RUTINAS(st):
    IMPRIME (Crear, Listar, Editar, Volver)
    op ← leer

    SI op = "1":
        SI catálogo vacío → PRINT("Crea ejercicios primero"); MENU_RUTINAS(st)
        nombre ← REPETIR_HASTA(BUSCAR_RUTINA(st,n)=NULO, "Nombre rutina: ", "Duplicado")
        desc ← INPUT_NO_VACIO("Descripción: ")
        PRINT("Ejercicios disponibles:"); LISTAR_EJERCICIOS(st)
        sel ← INPUT_NO_VACIO("Nombres (coma): ")
        nombres ← PARSEAR_COMAS(sel)
        INTENTAR st2 ← CREAR_RUTINA(st, nombre, desc, nombres); PRINT("Creada"); MENU_RUTINAS(st2)
        SI ERROR e: PRINT("[Error]"); MENU_RUTINAS(st)

    SI op = "2": LISTAR_RUTINAS(st); MENU_RUTINAS(st)

    SI op = "3":
        nombre ← INPUT_NO_VACIO("Rutina a editar: ")
        r ← BUSCAR_RUTINA(st, nombre)
        SI r = NULO → PRINT("No existe"); MENU_RUTINAS(st)
        SINO SUBMENU_EDITAR_RUTINA(st, r)

    SI op = "4": MENU_PRINCIPAL(st)
    OTRO: PRINT("Opción no válida"); MENU_RUTINAS(st)

PROCEDIMIENTO SUBMENU_EDITAR_RUTINA(st, r):
    IMPRIME (Agregar ej, Eliminar ej, Actualizar ej, Modificar datos, Ver duración, Listar ejercicios, Volver)
    op ← leer

    SI op = "1":
        SI catálogo vacío → PRINT("Catálogo vacío"); SUBMENU_EDITAR_RUTINA(st, r)
        LISTAR_EJERCICIOS(st)
        nombre_ej ← INPUT_NO_VACIO("Ejercicio a agregar: ")
        INTENTAR st2 ← RUTINA_AGREGAR_EJERCICIO_ST(st, r.nombre, nombre_ej)
                PRINT("Agregado")
                r2 ← BUSCAR_RUTINA(st2, r.nombre) o r
                SUBMENU_EDITAR_RUTINA(st2, r2)
        SI ERROR e: PRINT("[Error]"); SUBMENU_EDITAR_RUTINA(st, r)

    SI op = "2":
        nombre_ej ← INPUT_NO_VACIO("Ejercicio a eliminar: ")
        INTENTAR st2 ← RUTINA_ELIMINAR_EJERCICIO_ST(st, r.nombre, nombre_ej)
                PRINT("Eliminado")
                r2 ← BUSCAR_RUTINA(st2, r.nombre) o r
                SUBMENU_EDITAR_RUTINA(st2, r2)
        SI ERROR e: PRINT("[Error]"); SUBMENU_EDITAR_RUTINA(st, r)

    SI op = "3":
        nombre_ej ← INPUT_NO_VACIO("Ejercicio a actualizar: ")
        rep_txt ← leer("Nuevas reps (enter=mantener)")
        ser_txt ← leer("Nuevas series (enter=mantener)")
        rep ← si rep_txt="" entonces NULO sino entero(rep_txt)
        ser ← si ser_txt="" entonces NULO sino entero(ser_txt)
        INTENTAR st2 ← RUTINA_ACTUALIZAR_EJERCICIO_ST(st, r.nombre, nombre_ej, rep, ser)
                PRINT("Actualizado")
                r2 ← BUSCAR_RUTINA(st2, r.nombre) o r
                SUBMENU_EDITAR_RUTINA(st2, r2)
        SI ERROR e: PRINT("[Error]"); SUBMENU_EDITAR_RUTINA(st, r)

    SI op = "4":
        nuevo ← leer("Nuevo nombre (enter=mantener)")
        desc ← leer("Nueva descripción (enter=mantener)")
        INTENTAR st2 ← EDITAR_RUTINA(st, r.nombre,
                                     nuevo_nombre = (NULO si nuevo="" sino nuevo),
                                     nueva_desc   = (NULO si desc=""  sino desc))
                PRINT("Datos actualizados")
                r2 ← BUSCAR_RUTINA(st2, (nuevo ≠ "" ? nuevo : r.nombre)) o r
                SUBMENU_EDITAR_RUTINA(st2, r2)
        SI ERROR e: PRINT("[Error]"); SUBMENU_EDITAR_RUTINA(st, r)

    SI op = "5":
        PRINT("Duración total: " + MINUTOS_A_TEXTO(RUTINA_DURACION_TOTAL_MIN(r)))
        SUBMENU_EDITAR_RUTINA(st, r)

    SI op = "6":
        SI r.ejercicios vacío → PRINT("(Sin ejercicios)")
        SINO imprimir recursivamente " • " + STR_EJERCICIO(e)
        SUBMENU_EDITAR_RUTINA(st, r)

    SI op = "7":
        MENU_RUTINAS(st)

    OTRO:
        PRINT("Opción no válida"); SUBMENU_EDITAR_RUTINA(st, r)

SI __main__:
    st ← ESTADO_VACIO()
    INTENTAR:
        MENU_PRINCIPAL(st)
    SI CAPTURA KeyboardInterrupt:
        PRINT("¡Hasta luego!")
